//Заметки по ES5 JS!

// Типы данных (всего - 6)
// number - 4, 4.32 Нет разделения на дробное и целое!
// Строки как в Python
// Boolean как в Python, только с маленькой буквы!

// И еще 3:
// null
// object ({objKey: "balue"})
// undefined - Значение неопределено!
// null - Значение отсутствует/пустое значение.

// ООП в JS нет, есть полиморфизм.
// В JS практически нет Exeptions
// ; - Можно ставить, можно - нет, но в некоторых местах она нужна! Лучше всегда ставить!

'use strict'; // Необходимо всегда писать в самом начале скрипта! Строгий режим/Современный стандарт, для обратной совместимости!
// Если указать эту строку внутри функции, то современный режим будет работать только внутри функции!

// Новое объявление переменной в ES6!
let a = 2;  // Переменная с ограниченной областью видимости, только в scope {...} 
// И константы в ES6
const ARR = [1, 2, 3];
ARR.push(5)  // (4) [1, 2, 3, 5]
ARR = 3;  // Error  // Нельзя переназначить!

// В JS принято писать в стиле camelCase
// Ковычки могуть быть и те и другие.
var s = 'My var';
var myVar = "My var"

s = undefined
console.log(s)
// undefined
s = null
console.log(s)
// null
// Результат typeof(null) == "object" - true - это официально признанная ошибка в языке, 
// которая сохраняется для совместимости. На самом деле null – это не объект, а отдельный тип данных.


alert( 1 / 0 ); // Infinity, бесконечность.
alert( "нечисло" * 2 ); // // Nan - не число!, ошибка

var myVar = "My var"
s = 'My var'
console.log(s == myVar)  // Вывод на экран
// true
console.log(s === myVar)
// true
console.log(typeof(s))  //console.log(typeof s)
// string
console.error(s)  // Вывод ошибок
// My var  // Error

// == или ===
// Сравнение === проверяет точное равенство, включая одинаковый тип. Это самый очевидный и надёжный способ сравнения.
// Остальные сравнения == < <= > >= осуществляют числовое приведение типа
1 == '1'
// true  // Так как JS пытается првести к типу

1 === '1'
// false

// Объекты (Почти подобие словарей Python)
var o = {}
console.log(o)
// {}
console.log(typeof(o))
// object

var o = {1: 'a', 2: 'b', 3: 'c'}
console.log(o[1])
// a
console.log(Object.keys(o))
// [ '1', '2', '3' ]


// Объект в JS - это как dict в Python!
// Наследования нет, классов нет!
o['key'] = 12
console.log(o.key)  // Но уже ['some key'] через точку не получится!
// 12
console.log(o["key"])
// 12

// Списки - так же, как и в Python, но это не тип, а - объект! О_о
// В данном случае ключ 0 = 1, ключ 1 = 2 и ключ 2 = 3!
var list = [1, 2, 3]
// (3) [1, 2, 3]
console.log(typeof(list))
// object
list.push('str')  // Добавление в список
console.log(list)
// 4) [1, 2, 3, "str"]
console.log(list.length)  // Длина массива (У словарей(объектов в JS) такого метода нет)


// Логическая арифметика
// Или - ||
alert( true || true ); // true
alert( false || true ); // true
alert( true || false ); // true
alert( false || false ); // false

// оператор ИЛИ вычисляет ровно столько значений, сколько необходимо – до первого true
var x;
true || (x = 1);
alert(x); // undefined, x не присвоен
// А в примере ниже первый аргумент – false, так что ИЛИ попытается вычислить второй, запустив тем самым присваивание:

var x;
false || (x = 1);
alert(x); // 1


var hour = 9, isWeekend = true;
if (hour < 10 || hour > 18 || isWeekend) {
    alert('Upssss.')
}

// И - &&
// Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные – то последнее значение.
alert( true && true ); // true
alert( false && true ); // false
alert( true && false ); // false
alert( false && false ); // false

var hour = 12,
  minute = 30;
if (hour == 12 && minute == 30) {
  alert( 'Время 12:30' );
}

if (1 && 0) { // вычислится как true && false
    alert( 'не сработает, т.к. условие ложно' );
  }

// Приоритет у && больше, чем у ||
// Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
 alert( 5 || 1 && 0 ); // 5

 // НЕ - !
alert(!true)  // false


// Преобразование типов. В JS особо не принято. Есть строка - работай со строкой.
// Типизация слабая!
+'1' //  FUCKING FUCK
// 1
alert(String(null) == 'null')  // String с большой буквы
// true
alert( "123" + undefined );
// "123undefined"
alert(Number('123'))  // Number с большой буквы
// 123
var a = +"123"; // 123
// ==
var a = "123"
Number(a); //123

var a = 12 
Boolean(a);  //12
// ==
!!a

Boolean(0)
// false
!1
// false
!!1
// true
!true
// false

// Еще как вариант
parseInt('1')
// 1
parseInt('1v')
// 1
parseFloat('14.2sdf')
// 14.2


/*
Скрипты вставляются на страницу как текст в теге <script>, либо как внешний файл через <script src="путь"></script>
Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async – нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async – нет.
*/

// Договоренность о объявлении констант:
// Технически, константа является обычной переменной, то есть её можно изменить. Но мы договариваемся этого не делать.
var COLOR_RED = '#F00'

// Таблица приоритетов
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
var x = 2 * 2 + 1;
alert( x ); 
// 5

var apples = "2";
var oranges = "3";
alert(apples + oranges);  
//'23'
alert( +apples + +oranges ); 
// 5, число, оба операнда предварительно преобразованы в числа

var a = 1;
var b = 2;
var c = 3 - (a = b + 1);
alert( a ); 
// 3
alert( c ); 
// 0

alert( 5 % 2 ); 
// 1

var i = 2;
i++;      // более короткая запись для i = i + 1.
alert(i); 
// 3

var i = 2;
i--;      // более короткая запись для i = i - 1.
alert(i); 
// 1

// Если результат оператора не используется, а нужно только увеличить/уменьшить 
// переменную – без разницы, какую форму использовать:
// ---------------------------
var i = 0;
i++;
++i;
alert( i ); 
// 2

// !!! 
var i = 1;
var a = ++i;  // Префиксная форма. Если хочется тут же использовать результат.
alert(a); 
// 2

var i = 1;
var a = i++; // Постфиксная форма. Если нужно значение до увеличения.
alert(a); 
// 1

alert( 2 * i++ ); // 2,  выполнился раньше но значение вернул старое
alert( i ); // 2
alert( 2 * i++ ); // 4
alert( i ); // 3

var i = 1;
alert( 2 * ++i ); // 4
alert( i ); // 2
alert( 2 * ++i ); // 6
alert( i ); // 3
// ---------------------------

// Разница между i++ и ++i является значением выражения.
// Значение i++ является значением i до приращения. Значение ++i является значением i после приращения.
// https://learn.javascript.ru/while-for  В самом низу
var i = 42;
alert(i++); // shows 42
alert(i); // shows 43
i = 42;
alert(++i); // shows 43
alert(i); // shows 43

var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5). Так можно сделать для операторов +,-,*,/,%

// Строки сравниваются побуквенно.
// Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).
// Значения null и undefined равны == друг другу и не равны ничему другому.
// В обычном операторе == есть «проблема» – он не может отличить 0 от false:
 alert( 0 == false ); // true
// Та же ситуация с пустой строкой:
 alert( '' == false ); // true
// Это естественное следствие того, что операнды разных типов преобразовались к числу. 
// Пустая строка, как и false, при преобразовании к числу дают 0.
// Что же делать, если всё же нужно отличить 0 от false?
// Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.
// Если тип разный, то они всегда возвращают false:
 alert( 0 === false ); // false, т.к. типы различны


//  prompt как и alert - модальные окна. То есть, пока их не закрыть, работа со страницей не продолжится.

var years = prompt('Сколько вам лет?', 100);  // Esc - отмена окна
// 'Сколько вам лет?' - Заголовок
// 100 - значение, которое показывается в строке ввода по умолчанию.
alert('Вам ' + years + ' лет!')

var test = prompt("Тест");
var test = prompt("Тест", '');   // Рекомендуется всегда ставить второй аргумент( для совместимости в IE)

var isAdmin = confirm("Вы - администратор?");  // OK or Cancel
alert( isAdmin ); // true or false

